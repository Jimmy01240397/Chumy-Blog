<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/myfav.png type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><meta property="og:url" content="https://blog.chummydns.com/blogs/tunnel-injection/"><meta property="og:site_name" content="Chumy's Blog"><meta property="og:title" content="到處都有免費 VPN -- Tunnel Injection"><meta property="og:description" content="Tunnel Injection English
TL;DR 這篇文章講述了大多數 stateless tunnel protocol 的缺陷以及我如何把他們變成一個僅僅需要 5 行 linux ip 指令就能夠設定好的免費 VPN
感謝 在進入正題前這邊感謝 seadog007 的 STUIX，因為我的網路的 ASN 主要是在 STUIX 做交換的，並且也用到他們很多的資源做測試。
也感謝 NCSE 特別幫我在我測試的時候幫我加一點 IPT 的流量。
前言 這是一個講述我如何從研究一個協議到讓全世界都有我的 VPN 的小故事
事情是這樣發生的，大約在我大一的時候在 cloud native 聽到有關於 segment routing v6 這個酷東西，因此在大二的時候就有稍微研究一下同時也大概理解它的原理，至於這東西到底怎麼運作的，因為不是這篇文的重點所以就不談，可能之後會發其他的文章討論這個。
大三的時候因為接到 2024 CGGC aka 一場台灣辦的 CTF 的出題邀請，因此就開始在想梗。
然而在某天洗澡的時候突然仔細回味了一下就突然想到了這個非常酷的利用手法，順帶一題這題只有 seadog007 有打出來
這是 seadog007 幫我畫的攻擊手法的詳細圖
What is Tunnel 大家最耳熟能詳的 Tunnel 應該就是 VPN 了，因為 VPN 基本上就是一種 Tunnel，用很多組加密或未加密的 Tunnel 組合成的虛擬網路就是 VPN 的核心概念。
那它的運作原理其實很簡單，基本上就是信封袋外面再加封一層信封袋的概念。
用網路的說法講就是，當 packet 從 tunnel 的網卡離開時，負責處理這個 tunnel 的程式就會把這個封包的內容封裝成這個 tunnel protocol 的格式以後作為 tcp 或 udp 又或者是某個 L3 的 protocol 的 payload 從實體網卡（或下一層 tunnel 網卡）送出。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2025-08-28T13:50:00+08:00"><meta property="article:modified_time" content="2025-08-28T13:50:00+08:00"><meta property="article:tag" content="Cyber Security"><meta property="article:tag" content="Networking"><meta name=twitter:card content="summary"><meta name=twitter:title content="到處都有免費 VPN -- Tunnel Injection"><meta name=twitter:description content="Tunnel Injection English
TL;DR 這篇文章講述了大多數 stateless tunnel protocol 的缺陷以及我如何把他們變成一個僅僅需要 5 行 linux ip 指令就能夠設定好的免費 VPN
感謝 在進入正題前這邊感謝 seadog007 的 STUIX，因為我的網路的 ASN 主要是在 STUIX 做交換的，並且也用到他們很多的資源做測試。
也感謝 NCSE 特別幫我在我測試的時候幫我加一點 IPT 的流量。
前言 這是一個講述我如何從研究一個協議到讓全世界都有我的 VPN 的小故事
事情是這樣發生的，大約在我大一的時候在 cloud native 聽到有關於 segment routing v6 這個酷東西，因此在大二的時候就有稍微研究一下同時也大概理解它的原理，至於這東西到底怎麼運作的，因為不是這篇文的重點所以就不談，可能之後會發其他的文章討論這個。
大三的時候因為接到 2024 CGGC aka 一場台灣辦的 CTF 的出題邀請，因此就開始在想梗。
然而在某天洗澡的時候突然仔細回味了一下就突然想到了這個非常酷的利用手法，順帶一題這題只有 seadog007 有打出來
這是 seadog007 幫我畫的攻擊手法的詳細圖
What is Tunnel 大家最耳熟能詳的 Tunnel 應該就是 VPN 了，因為 VPN 基本上就是一種 Tunnel，用很多組加密或未加密的 Tunnel 組合成的虛擬網路就是 VPN 的核心概念。
那它的運作原理其實很簡單，基本上就是信封袋外面再加封一層信封袋的概念。
用網路的說法講就是，當 packet 從 tunnel 的網卡離開時，負責處理這個 tunnel 的程式就會把這個封包的內容封裝成這個 tunnel protocol 的格式以後作為 tcp 或 udp 又或者是某個 L3 的 protocol 的 payload 從實體網卡（或下一層 tunnel 網卡）送出。"><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--text-link-color:#007bff;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color)!important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>到處都有免費 VPN -- Tunnel Injection | Chumy's Blog</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/myfav.png width=30 height=30 class="d-inline-block align-top">
Chumy's Blog</a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder='Ctrl + k to Search...' aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation"><svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder='Ctrl + k to Search...' aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About Me</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#education aria-label=education>Education</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#projects aria-label=projects>Projects</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#contact aria-label=contact>Contact</a></li><li class="nav-item navbar-text"><a class=nav-link href=/blogs title="Blog posts">Blog</a></li><li class="nav-item navbar-text"><a class=nav-link href=/cv.pdf title=CV>CV</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4">到處都有免費 VPN -- Tunnel Injection</h1><div class=text-center>Chumy
<small>|</small>
Aug 28, 2025
<span id=readingTime>min read</span></div></div><article class="page-content p-2"><h1 id=tunnel-injection>Tunnel Injection</h1><p><a href=/blogs/tunnel-injection-english>English</a></p><h2 id=tldr>TL;DR</h2><p>這篇文章講述了大多數 stateless tunnel protocol 的缺陷以及我如何把他們變成一個僅僅需要 5 行 linux ip 指令就能夠設定好的免費 VPN</p><h2 id=感謝>感謝</h2><p>在進入正題前這邊感謝 <a href=https://seadog007.work/>seadog007</a> 的 <a href=https://stuix.io/>STUIX</a>，因為我的網路的 ASN 主要是在 STUIX 做交換的，並且也用到他們很多的資源做測試。</p><p>也感謝 <a href=https://ncse.tw/>NCSE</a> 特別幫我在我測試的時候幫我加一點 IPT 的流量。</p><h2 id=前言>前言</h2><p>這是一個講述我如何從研究一個協議到讓全世界都有我的 VPN 的小故事</p><p>事情是這樣發生的，大約在我大一的時候在 cloud native 聽到有關於 segment routing v6 這個酷東西，因此在大二的時候就有稍微研究一下同時也大概理解它的原理，至於這東西到底怎麼運作的，因為不是這篇文的重點所以就不談，可能之後會發其他的文章討論這個。</p><p>大三的時候因為接到 <a href=https://cggc.nchc.org.tw/>2024 CGGC</a> aka 一場台灣辦的 CTF 的出題邀請，因此就開始在想梗。</p><p><img src=https://github.com/user-attachments/assets/15d204e5-72b9-4827-97a4-9abbcb51f621 alt=image></p><p><img src=https://github.com/user-attachments/assets/21be27d8-b269-47ee-8c1b-48f3831bea3d alt=image></p><p>然而在某天洗澡的時候突然仔細回味了一下就突然想到了這個非常酷的利用手法，順帶一題這題只有 <a href=https://seadog007.work/>seadog007</a> 有打出來</p><p>這是 <a href=https://seadog007.work/>seadog007</a> 幫我畫的攻擊手法的詳細圖</p><p><img src=https://github.com/user-attachments/assets/ac66ca21-eadc-4000-98d9-6133a3f8456d alt=image></p><h2 id=what-is-tunnel>What is Tunnel</h2><p>大家最耳熟能詳的 Tunnel 應該就是 VPN 了，因為 VPN 基本上就是一種 Tunnel，用很多組加密或未加密的 Tunnel 組合成的虛擬網路就是 VPN 的核心概念。</p><p>那它的運作原理其實很簡單，基本上就是信封袋外面再加封一層信封袋的概念。</p><p><img src=https://github.com/user-attachments/assets/6e5c692c-183f-41a2-a4d4-e03cb3eb4202 alt=image></p><p><img src=https://github.com/user-attachments/assets/c71b10e9-f6fa-473d-a94a-77e99d0a3dd5 alt=image></p><p>用網路的說法講就是，當 packet 從 tunnel 的網卡離開時，負責處理這個 tunnel 的程式就會把這個封包的內容封裝成這個 tunnel protocol 的格式以後作為 tcp 或 udp 又或者是某個 L3 的 protocol 的 payload 從實體網卡（或下一層 tunnel 網卡）送出。</p><p>接收時負責監聽這個 tunnel protocol 的程式從監聽的 port 接收到資料時把該 tunnel protocol 的 header 拆掉以後將內部的 raw data 直接作為 l3 或 l2 的 packet 送到 tunnel 網卡上。</p><p><img src=https://github.com/user-attachments/assets/88cf1d26-7f70-485e-8089-6e39ec9e4bca alt=image></p><p>而 stateless tunnel protocol 就是指說這個 tunnel protocol 你只要給他甚麼 tunnel protocol 的 packet 他就直接拆開然後轉送，沒做任何的驗證或者是握手。</p><h2 id=impact>Impact</h2><p>那沒有驗證會怎樣，基本上我只要能夠偽造出一個符合這個 tunnel protocol 的封包，我就可以做到將惡意的 packet 透過這個裸奔的 tunnel 轉送到 victim 的內網內，然而過往的研究基本上都是認為這個攻擊是只有單向的，頂多可以做一些 DDoS 而已。</p><p><img src=https://github.com/user-attachments/assets/9c57dd15-5db7-438b-9d39-d7871cd189aa alt=image></p><p><img src=https://github.com/user-attachments/assets/21321374-4940-4520-9e9a-618ce5ccb06e alt=image></p><p>包含今年 1 月剛出來的一篇<a href=https://www.top10vpn.com/research/tunneling-protocol-vulnerability/>研究</a></p><p><img src=https://github.com/user-attachments/assets/359e4baa-1152-4fe7-9445-976b6a74733b alt=image></p><p>這篇研究雖說有講到很多裸奔 stateless tunnel 的掃描方法，以及一些特定型號產品的 router 不會驗證 source ip 的問題，然而主要也都是 focus 在 DDoS 的攻擊面上。</p><p>然而事實上只需要把腦袋轉一下：我們其實並不需要來回都要過這個 tunnel 才對。</p><p>畢竟攻擊的核心是需要將流量「注入到 Tunnel 內」因此這邊就先取名叫做 Tunnel Injection。</p><h3 id=tunnel-injection-to-internal-network>Tunnel Injection to Internal Network</h3><p>第一個利用手法是我們可以做到 Interactive Internal Network Access</p><p>首先我們偽造出一個符合這個 tunnel protocol 的封包</p><p>外層的 source ip 是 attacker 的 public ip 或者一些 tunnel protocol 因為會驗證 source ip 所以這邊也可能需要做 ip spoofing，destination ip 是 victim tunnel 的 public ip。</p><p>內層的 source ip 是 attacker 的 <font color=red>public ip</font> 這個就是這邊的核心了，而 destination ip 就是你想要扁的 victim 內網機器的 <font color=red>private ip</font>。</p><p><img src=https://github.com/user-attachments/assets/7a95b8c2-cf6c-4d50-9439-1a7ff17d9f52 alt=image></p><p>送出去以後會發生甚麼事呢。</p><p>首先 packet 抵達 victim 的 router 時會被解封裝，並把內層的封包依照這台 router 的 routing table 做 forwarding，同時 conntrack table 會留下一條轉發的紀錄。</p><p><img src=https://github.com/user-attachments/assets/d0e5e518-0435-42b3-96c1-5529311bfd73 alt=image></p><p>然後內網的機器就會看到一個 src = <font color=red>public ip</font> dest = 自己 ip 的封包，因此他 response 理所當然會 src = 自己 ip dest = <font color=red>public ip</font></p><p><img src=https://github.com/user-attachments/assets/33f5e5d2-2954-457b-bae5-e43ba2b12040 alt=image></p><p>這個 packet 來到 victim router 的時候，因為 dest = <font color=red>public ip</font> 所以就會<font color=red>依照 routing table 做 forwarding 直接走 default gateway 出去</font>。</p><p>這邊同時要補充一點，因為一般的 router 不會對奇怪類型的封包做 SNAT 比如 TCP SYN/ACK、ICMP type 0 aka pong 因此回來的 packet 離開 victim router 的時候是不會被 NAT 也就是說 <font color=red>source ip 是 private ip</font> 這在某些場景是會有問題的。</p><p>那接著我們就可以從網路上收到這個來自 victim 內網的回應。</p><p><img src=https://github.com/user-attachments/assets/2a483ec0-2a7d-445a-a8cb-403f24bcd8bc alt=image></p><p>我們就能夠 Arbitrary Interactive Internal Network Access</p><iframe width=560 height=315 src="https://www.youtube.com/embed/KSNkpPdzw8o?si=pE8cLkI-OTlZILsh" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe><h3 id=tunnel-injection-to-external-network>Tunnel Injection to External Network</h3><p>在講攻擊手法之前我們先來看看 NAT 一般是怎麼實作的，這邊以 Linux 為例</p><p>在 Linux kernel base 的 router 上，一般我們毀使用 <code>netfilter</code> 與 <code>conntrack</code> 來處理 NAT，而最常見的指令介面會是 <code>iptables</code> 與 <code>nftables</code>，這邊以 <code>iptables</code> 為例</p><p>一般情況下要啟動 NAT 我們會下這條 <code>iptables</code> 指令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -t nat -A POSTROUTING -o wan -s 192.168.0.0/16 -j MASQUERADE
</span></span></code></pre></div><p>這條指令的意思是在確定出口網卡時當封包從 <font color=red>wan</font> 網卡離開時，如果 source ip 符合 192.168.0.0/16 就做 NAT 並使用 wan 網卡的 public ip 作為 source ip。</p><p>但是事實上其實很多 router 的廠商都會偷懶，只這樣寫</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -t nat -A POSTROUTING -o wan -j MASQUERADE
</span></span></code></pre></div><p>這條指令的意思是在確定出口網卡時當封包從 <font color=red>wan</font> 網卡離開時，就做 NAT 並使用 wan 網卡的 public ip 作為 source ip。</p><p>可以發現它少了 source ip 的檢查，所以事實上如果 source ip 已經是 public 他也會做 NAT，畢竟 <a href=https://datatracker.ietf.org/doc/html/rfc1918>RFC 1918</a> 只是定義而已，沒說你不能拿 public ip 當 private ip 用。</p><p>然而如果今天這台 router 同時有一個裸奔的 tunnel 再跑會怎樣呢？</p><p>答案是我們會得到一個<font color=red>免費的跳板</font></p><p>事實上我們只需要將前面 <a href=#tunnel-injection-to-internal-network>Tunnel Injection to Internal Network</a> 所說的內層的 destination ip 更改成你要 access 的外網 target public ip 就好。</p><p>一樣我們偽造出一個符合這個 tunnel protocol 的封包</p><p>外層的 source ip 是 attacker 的 public ip 或 ip spoofing 的 IP，destination ip 是 victim tunnel 的 public ip。</p><p>內層的 source ip 是 attacker 的 <font color=red>public ip</font> ，而 destination ip 這次就改成用<font color=red>你要 access 的外網 target public ip</font>。</p><p><img src=https://github.com/user-attachments/assets/ffbfa772-3f79-4701-ad49-b968441ba406 alt=image></p><p>packet 抵達 victim 的 router 時會被解封裝，並把內層的封包依照這台 router 的 routing table 做 forwarding，同時依照上面 <code>iptables</code> 做 NAT 的 source ip 轉換，同時 conntrack table 會留下一條 NAT 的轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/b120f257-d8b2-4392-a619-80133643455c alt=image></p><p>接著你要連的 target 就會收到你的 packet 並且可能會做 response，因為 source ip 已經因為上面所說的做 NAT 所以 target 看到的會是</p><p>src = <font color=red>victim public ip</font> dest = <font color=red>target public ip</font></p><p>因此 response 會是 src = <font color=red>target public ip</font> dest = <font color=red>victim public ip</font></p><p><img src=https://github.com/user-attachments/assets/92a6f6f4-293e-42ff-80be-e659a6bd32cd alt=image></p><p>接著 victim router 收到 packet 後會依照 conntrack 的紀錄作 destination ip 的復原，並且依照這台 router 的 routing table 做 forwarding</p><p><img src=https://github.com/user-attachments/assets/9ab444c2-9e01-4723-996e-e006786c340c alt=image></p><p>然後你就收到 response 了</p><p><img src=https://github.com/user-attachments/assets/9c24ec6f-6eae-4fe0-a7fd-df7588e38fd2 alt=image></p><p>我們就能夠 Arbitrary Interactive Pivoting Attack via Tunnel</p><p><img src=https://github.com/user-attachments/assets/6dfa50fa-0f75-46f5-acf2-b4d52f2a313c alt=image></p><iframe width=560 height=315 src="https://www.youtube.com/embed/EC9qySzo6J4?si=mF9rBsuFrUwao2-k" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe><h2 id=rpf-or-source-ip-verify-bypass>RPF or source ip verify bypass</h2><p>當你以為這樣就結束時現實往往會來一巴掌</p><p>還記得前面講 <a href=#tunnel-injection-to-internal-network>Tunnel Injection to Internal Network</a> 時所說的</p><pre tabindex=0><code>一般的 router 不會對奇怪類型的封包做 SNAT 比如 TCP SYN/ACK、ICMP type 0 aka pong 因此回來的 packet 離開 victim router 的時候是不會被 NAT 也就是說 source ip 是 private ip 這在某些場景是會有問題的。
</code></pre><p>而這邊所說的場景就是指 Reverse path forwarding (RPF) 或者 source ip verify</p><p><img src=https://github.com/user-attachments/assets/e80bb09f-a306-4308-944b-938e24e01da0 alt=image></p><p>首先絕大多數的 ISP 為了要防止客戶對外做 IP Spoofing 的攻擊，一般都會針對 client 方向的網卡開啟 RPF</p><p>RPF 就是指說，當網卡收到 packet 時，會拿 source ip 對一次 routing tables，如果這個 source ip 並不符合 routing tables 上送往這張網卡的任何規則的話，這個封包就會被 DROP 掉。</p><p>因此如果遇到 victim 的 ISP 有啟用這類防護的情況的話你是收不到 response 的，那該怎麼辦</p><h3 id=bypass-for-internal-network-access>Bypass for Internal Network Access</h3><p>這邊我們就來談談 P2P 網路是怎麼做 NAT hole punching 的</p><p>首先當雙方的 source port 提前知道，或者可預測的情況（以 p2p 應用程式的情況，會有一個 stun server 協助探測兩邊的 client 使用的 source port 是多少）</p><p>雙方可以同時朝對方的 public ip 與 port 發送一個 packet，這邊以 udp 為例</p><p><img src=https://github.com/user-attachments/assets/590fc3b4-e990-4ebb-8f8d-e44c20f9f30f alt=image></p><p>packet 經過 router 以後會做 NAT 並且同時 conntrack table 會留下一條 NAT 的轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/1a9e7d65-5fc1-44c0-bbed-92361eaed76d alt=image></p><p>兩個封包都各自抵達對方的 router，這邊可以發現抵達的時候 conntrack table 已經有符合條件的 NAT 轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/4e531fdf-9045-44aa-bb86-2b1b7189c7e2 alt=image></p><p>因此接著就會依照 conntrack 的紀錄作 destination ip 的復原</p><p><img src=https://github.com/user-attachments/assets/368274e7-f142-4270-becf-f3589dfd908a alt=image></p><p>以上就是整個 NAT hole punching 的大概流程，如果說是 tcp 的話會更複雜一點，因為 tcp 是 statefull，有興趣可以去查 TCP Simultaneous Open，剛好今年的 <a href=https://ctf2025.hitcon.org/dashboard/#19>HITCON CTF 2025 有類似的題目</a> 畢竟 TCP Self Connect 本身也是一種 TCP Simultaneous Open 的特殊案例。</p><p>順帶一題我會清楚整個 P2P 傳輸的流程也歸功於我高中時曾經<a href=https://github.com/Jimmy01240397/NetworkServicePackage>手刻過整個 P2P 做 NAT hole punching 的流程，也手刻過 STUN server</a> <del>雖說現在看他的 code 醜醜的就是了</del>，之前有些人總是問我為甚麼要自己造輪子，但是我認為自己手刻輪子也是一種樂趣，並且這樣才能夠真正的學到東西，畢竟使用自己寫出來的工具也是一種樂趣吧？</p><p>總之我們可以理解為從內部發 packet 做完 NAT 以後，其時就變相地做完了一個有限制的 port forwarding</p><p>再加上我們可以利用 Tunnel Injection 做到單方向任意存取內網或者從內網發 packet，那我們是否可以手動做 NAT hole punching 以後直接從外網做存取呢？</p><p>事實上是可以的。以下用 TCP 舉例。</p><p>我們利用 Tunnel Injection 在 victim 的內網發送 TCP SYN 來做 hole punching</p><p>source ip 是你想要扁的 victim 內網機器的 <font color=red>private ip</font>，而 destination ip 是 attacker 的 <font color=red>public ip</font>。</p><p><img src=https://github.com/user-attachments/assets/34fa43d2-f10d-4c30-bf6b-9bba2537b88d alt=image></p><p>packet 抵達 victim 的 router 時會依照這台 router 的 routing table 做 forwarding，接著做 NAT 的 source ip 轉換，同時 conntrack table 會留下一條 NAT 的轉換紀錄。</p><p>這樣 hole punching 就完成了</p><p><img src=https://github.com/user-attachments/assets/68ca12ef-176c-42c8-9306-406007a1eaa2 alt=image></p><p>接著朝著這個打好的洞發 tcp SYN</p><p>source ip 是 attacker 的 <font color=red>public ip</font>，而 destination ip 是你想要扁的 victim 內網機器的 <font color=red>private ip</font>。</p><p><img src=https://github.com/user-attachments/assets/6a05f51d-89e9-4b54-a0d8-a1af4b66f30e alt=image></p><p>packet 會依照 conntrack 的紀錄作 destination ip 的復原，並且依照這台 router 的 routing table 做 forwarding 轉到 victim 的內網機器</p><p><img src=https://github.com/user-attachments/assets/9da739d2-8185-4c74-a558-1268905a25b5 alt=image></p><p>victim 的內網機器收到後會回 TCP SYN/ACK</p><p><img src=https://github.com/user-attachments/assets/dd125103-65b5-4ff8-a28d-106f12453ba6 alt=image></p><p>並且 source ip 會很正常的 NAT 成 victim 的 public ip</p><p><img src=https://github.com/user-attachments/assets/dfc538ec-f8bd-4f92-ad21-d53ad41c4f77 alt=image></p><p>接著 attacker 就回 ACK</p><p><img src=https://github.com/user-attachments/assets/a2f3b7a5-61fd-45f8-a810-3076ed283495 alt=image></p><p>然後 connection 就建立起來了，可以快樂傳資料到內網了</p><p><img src=https://github.com/user-attachments/assets/30dec908-b538-4163-8151-7adc197584d2 alt=image></p><p>然而上面的流程其實只有對 UDP 完全成立。</p><p>TCP 只有部份的 router 或較舊的 Linux kernel 成立而已。</p><p>主要是因為現今的 Linux kernel 的 conntrack 做 TCP Simultaneous Open 會嚴格檢查封包傳輸的行為是否符合 TCP Simultaneous Open 的行為，如果有一邊的 SYN/ACK 沒收到，你會發現他的 state 會永遠停留在 <code>SYN_SENT2</code>，這時候內網對外發 TCP PUSH 的時候<font color=red>依然不會被 NAT 成 victim 的 public ip</font></p><p>因為上面的流程會少 attacker 發向 victim 內網機器的 SYN/ACK 因此永遠不會 ESTABLISHED</p><p>那如果我補發 attacker 發向 victim 內網機器的 SYN/ACK 是否就能解決呢？</p><p>由於 conntrack 只要看到任何 TCP RST 就會直接把這條紀錄轉成 close state 並且在幾秒後 free 掉，並且一般的系統在收到來源不明，或者是不符合握手流程的 TCP 包會直接回 TCP RST（因為 TCP SYN 是我們手動利用 Tunnel Injection 打出去的，因此 victim 內網機器壓根不認識這個 SYN/ACK）</p><p>雖說這種作法在一些會 DROP 掉 TCP RST 的內網環境可能是可以成功的，但是這邊還是以預設狀況為主比較好。</p><p>那該怎麼解決問題呢</p><p>仔細看 sysctl 的參數我們會發現 conntrack 的 tcp close 紀錄的壽命只有 10 秒，之後紀錄就會被 free 掉</p><p><img src=https://github.com/user-attachments/assets/fcab59ab-27a7-4a7f-a1e5-10c82ae13728 alt=image></p><p>然後還有一個有趣的參數是 net.netfilter.nf_conntrack_tcp_loose</p><p><img src=https://github.com/user-attachments/assets/84632096-8e77-4e61-bb89-35a1617bfbc3 alt=image></p><p>這個參數預設是 1</p><p>那他有甚麼意思呢？</p><p>當 net.netfilter.nf_conntrack_tcp_loose 為 1 時，允許在 conntrack 沒有任何符合條件的紀錄時收到 PUSH 或 ACK 做 NAT</p><p>也就是說當我 conntrack 沒有任何符合條件的紀錄時，內網向外發一個 TCP PUSH 或 ACK 他會直接生出一個 ESTABLISHED state 的 NAT 紀錄</p><p>那這就非常好玩了，因為 close state 時間夠短，並且 TCP 是會重傳的，我們可以手動發 TCP RST 來 free 掉 conntrack record 然後內網發 PUSH 出來就直接變成 ESTABLISHED state</p><p>所以這邊在講一次流程：</p><p>我們利用 Tunnel Injection 在 victim 的內網發送 TCP SYN 來做 hole punching</p><p>source ip 是你想要扁的 victim 內網機器的 <font color=red>private ip</font>，而 destination ip 是 attacker 的 <font color=red>public ip</font>。</p><p><img src=https://github.com/user-attachments/assets/34fa43d2-f10d-4c30-bf6b-9bba2537b88d alt=image></p><p>packet 抵達 victim 的 router 時會依照這台 router 的 routing table 做 forwarding，接著做 NAT 的 source ip 轉換，同時 conntrack table 會留下一條 NAT 的轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/68ca12ef-176c-42c8-9306-406007a1eaa2 alt=image></p><p>接著朝著這個打好的洞發 tcp SYN</p><p>source ip 是 attacker 的 <font color=red>public ip</font>，而 destination ip 是你想要扁的 victim 內網機器的 <font color=red>private ip</font>。</p><p><img src=https://github.com/user-attachments/assets/6a05f51d-89e9-4b54-a0d8-a1af4b66f30e alt=image></p><p>packet 會依照 conntrack 的紀錄作 destination ip 的復原，並且依照這台 router 的 routing table 做 forwarding 轉到 victim 的內網機器</p><p><img src=https://github.com/user-attachments/assets/9da739d2-8185-4c74-a558-1268905a25b5 alt=image></p><p>victim 的內網機器收到後會回 TCP SYN/ACK</p><p><img src=https://github.com/user-attachments/assets/dd125103-65b5-4ff8-a28d-106f12453ba6 alt=image></p><p>並且 source ip 會很正常的 NAT 成 victim 的 public ip</p><p><img src=https://github.com/user-attachments/assets/dfc538ec-f8bd-4f92-ad21-d53ad41c4f77 alt=image></p><p>接著 attacker 就回 ACK</p><p><img src=https://github.com/user-attachments/assets/a0f2a086-4755-4169-9085-daf7b523b6fe alt=image></p><p>我們這邊發一個 PUSH 進去，可能是 HTTP 的 request 之類的</p><p><img src=https://github.com/user-attachments/assets/3f55be71-accc-4b0e-8aa1-878ac136cc92 alt=image></p><p>因為上面講的機制，內網出來的 PUSH 會被 DROP，attacker 沒收到資料自然不會回 ACK，victim 內網機器沒收到 ACK 就會一直重傳 TCP PUSH</p><p><img src=https://github.com/user-attachments/assets/ef676fa9-b7d5-492b-86bd-ffd606b8c0bb alt=image></p><p>接著我們利用 Tunnel Injection 從內網打一個 TCP RST 出來，手動 free 掉這條 conntrack record</p><p><img src=https://github.com/user-attachments/assets/7671e6c4-8041-4034-b9da-93fd323e0b1d alt=image></p><p>Free 掉以後當內網重傳 TCP PUSH</p><p><img src=https://github.com/user-attachments/assets/115257d7-8133-4b60-9dd9-3177cbb7583d alt=image></p><p>就會成功被 NAT 並且 conntrack table 會留下一條 NAT <font color=red>ESTABLISHED state</font> 的轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/b04c2350-c5b4-428f-b55d-7f665be6a19e alt=image></p><p>然後 connection 就建立起來了，可以快樂傳資料到內網了</p><p><img src=https://github.com/user-attachments/assets/30dec908-b538-4163-8151-7adc197584d2 alt=image></p><p>以上我們就成功做到 RPF bypass 的 Internal Network Access 了。</p><iframe width=560 height=315 src="https://www.youtube.com/embed/1YkltH1gCz4?si=V0iYDhGsGvKnd70O" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe><h3 id=bypass-for-external-network-access>Bypass for External Network Access</h3><p>前面會比較簡單是因為整個 Bypass 過程中只用到一次的 NAT，但是對於 External Network Access 我們如果要 Bypass 就需要做兩次 NAT。</p><ol><li>把去程的 source ip 換成 victim 的 public ip</li><li>把回程的 source ip 換成 victim 的 public ip</li></ol><p>那該怎麼辦呢？</p><p>這時候如果 victim 內網還有一層 tunnel 跟 NAT 的組合，我們就可以<font color=red>串一個 NAT Chain 出來</font></p><p><img src=https://github.com/user-attachments/assets/6e0361aa-f2ed-48ba-8bfa-b97eae5e9a5a alt=image></p><p>我們利用 Tunnel Injection 在 victim 的第一層內網發送 TCP SYN 來做 hole punching</p><p>source ip 是 <font color=red>target 的 public ip</font>，而 destination ip 是 <font color=red>attacker 的 public ip</font>。</p><p><img src=https://github.com/user-attachments/assets/eccd387e-42e7-44eb-8962-faa95ec0ffb2 alt=image></p><p>packet 抵達 victim 的第一層 router 時會依照這台 router 的 routing table 做 forwarding，接著做 NAT 的 source ip 轉換，同時 conntrack table 會留下一條 NAT 的轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/9a6223c9-c748-41be-81c2-9ae450bdc4e7 alt=image></p><p>然後我們必須故意打一個 TCP SYN 來讓第一層 router 的 conntrack record 轉成 SYN_SENT2 state</p><p><img src=https://github.com/user-attachments/assets/674aa743-e4b6-4bad-b05b-ea7763fb6f79 alt=image></p><p>這個封包轉往 target 時就會被 RPF 給 DROP 掉</p><p><img src=https://github.com/user-attachments/assets/e8b0399a-96c1-4b5a-98be-a9f29b356cba alt=image></p><p>我們利用 Tunnel Injection 在 victim 從第二層內網發送 TCP SYN 到 target</p><p>source ip 是 <font color=red>attacker 的 public ip</font>，而 destination ip 是 <font color=red>target 的 public ip</font>。</p><p><img src=https://github.com/user-attachments/assets/59105cb3-cdd6-4808-b561-499c8b839fcf alt=image></p><p><img src=https://github.com/user-attachments/assets/0689a0c6-40e9-4ee9-b5f2-43aa9fed3f1a alt=image></p><p>TCP SYN 會被第二層 router 做 NAT 的 source ip 轉換，同時 conntrack table 會留下一條 NAT 的轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/00729446-faa7-401c-b282-030aae85a543 alt=image></p><p>TCP SYN 會被第一層 router 做 NAT 的 source ip 轉換，同時 conntrack table 又會留下一條 NAT 的轉換紀錄。</p><p><img src=https://github.com/user-attachments/assets/7be48293-0ae1-4f67-b4c1-bad4cae8c9d0 alt=image></p><p>target 會回 SYN/ACK 並且依照 conntrack 的紀錄作 destination ip 的復原</p><p><img src=https://github.com/user-attachments/assets/61f1d773-6e80-4f93-a80f-eec9a253db2e alt=image></p><p>destination ip 變成第二層 router 的 wan IP，並傳到第二層 router，一樣依照 conntrack 的紀錄作 destination ip 的復原</p><p><img src=https://github.com/user-attachments/assets/0b813ca9-8604-48ad-9eb9-8f18c31d0416 alt=image></p><p>destination ip 變成 attacker 的 public ip，並傳到第一層 router</p><p><img src=https://github.com/user-attachments/assets/a84a2fcb-a332-4680-8f34-2d07c5cfc5b3 alt=image></p><p>這時候很有趣的是 source ip 是 target 的 public ip 當好對應到之前在第一層 route 打好的 conntrack record 的 NAT 轉換紀錄。</p><p>因此他會一樣依照 conntrack 的紀錄作 source ip 的 NAT</p><p><img src=https://github.com/user-attachments/assets/48ecb285-68ef-4a9f-82aa-030b7e9d910a alt=image></p><p>attacker 收到的就是 source ip 為 <font color=red>victim 的第一層 router 的 public ip</font></p><p><img src=https://github.com/user-attachments/assets/511aede6-4882-4676-a2a8-2204684283d7 alt=image></p><p>接下來的流程就跟前面講 <a href=#bypass-for-internal-network-access>Bypass for Internal Network Access</a> 的流程一樣了</p><p>回 ACK</p><p><img src=https://github.com/user-attachments/assets/ac76ca3c-6eae-40fb-9aba-fa0a0864c138 alt=image></p><p>發 push</p><p><img src=https://github.com/user-attachments/assets/32ab2ce8-6caa-482a-add0-144899e0d438 alt=image></p><p>發 RST 來 free 掉 conntrack record</p><p><img src=https://github.com/user-attachments/assets/5f543174-edbe-4aa2-8aef-bf269000150d alt=image></p><p>target 持續重傳</p><p><img src=https://github.com/user-attachments/assets/94a00362-e077-46f6-8c43-0cc7cda68ab3 alt=image></p><p>打回來成功 NAT 並且 conntrack record ESTABLISHED</p><p><img src=https://github.com/user-attachments/assets/6c0dbb36-6cf7-4b89-b55d-56acf98acaa6 alt=image></p><p>以上我們就成功做到 RPF bypass 的 External Network Access 了。</p><iframe width=560 height=315 src="https://www.youtube.com/embed/_GcIFKyjGmE?si=qWA0cVCgFotki8nm" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe><p>而且事實上 NAT Chain 的利用除了上面用來繞 RPF 外，也可以用來在 Internal Network Access 時繞一些 server 對 source 的檢查，畢竟有些 server 也是有自己的 firewall 的。</p><h2 id=l2-tunnel-abuse>L2 Tunnel Abuse</h2><p>前面主要都是在談 L3 Tunnel 的利用，而 L2 Tunnel 因為多了一層 Ethernet header 要封，所以比較麻煩一些，因為我們需要 router 或者內往機器的 mac address 才可以達成利用，又或者可以做 broadcast 或 multicast。</p><p>那我們有沒有可能利用 broadcast 或 multicast 來 leak 一些有用的資訊或者 mac address 呢？</p><p>是有可能的</p><p>當內網除了有 IPv4 以外還啟用了 IPv6 並且有 unicast address 時，由於預設情況下 ICMPv6 request 是允許 multicast 的，因此我們可以用 multicast 的 IPv6 ping 來 leak IPv6 address</p><p><img src=https://github.com/user-attachments/assets/abc2edae-bf6e-46f9-ae66-001080bdffb2 alt=image></p><p>首先我們用 multicast mac address 以及 attacker 的 public IPv6 address 在 victim 內網 multicast IPv6 ping</p><p><img src=https://github.com/user-attachments/assets/ea7fd3e3-1d59-403d-a125-cbc0243b043e alt=image></p><p>Switch 會把這個 ping multicast 給所有有訂閱這個 multicast mac address 的設備</p><p><img src=https://github.com/user-attachments/assets/5465ba53-bc01-486a-806f-8472c1c52097 alt=image></p><p>victim 內網設備會回 ICMP pong 給 attacker</p><p><img src=https://github.com/user-attachments/assets/950c89a1-933d-4d69-a962-b042104c807c alt=image></p><p>我們便可拿到所有內網設備的 IPv6 address</p><p><img src=https://github.com/user-attachments/assets/4ed1c850-90c0-4e26-824f-82a9a49e0f22 alt=image></p><iframe width=560 height=315 src="https://www.youtube.com/embed/Eqb1dv2bPzk?si=gX9q73c6ubSatqVy" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe><p>那有 IPv6 address 可以幹嘛呢？</p><p>根據 <a href=https://datatracker.ietf.org/doc/html/rfc4291>RFC 4291</a> 所記載的 SLAAC IPv6 address 的動態生成方式中，有一種方式是用 mac address 算出來的</p><p><img src=https://github.com/user-attachments/assets/39dad163-bb73-420f-bced-ca58c684cb1c alt=image></p><p>這個算出的 IPv6 address 我們是可以逆推回 mac address 的，並且 linux 預設便是使用此方法生成 IPv6</p><p><img src=https://github.com/user-attachments/assets/9e120a86-764d-4558-992c-07732265b8e0 alt=image></p><p>此外，另外一名來自趨勢科技的研究員 <a href=https://github.com/123ojp>123ojp</a> 也剛好跟我一樣再研究這個方面的攻擊手法，並且有發現針對 VXLAN 這個 L2 Tunnel 更為高效的利用手法，有興趣可以去看他在 <a href=https://defcon.org/html/defcon-33/dc-33-speakers.html#content_60316>DEFCON 33 的議程</a></p><h2 id=ipsec>IPSec</h2><p>或許大家以為只要啟用 IPSec 就可以防護這類的攻擊，但是事實上只要你的 IPSec 有配置不當，即使開 IPSec 也可能會遭受攻擊。</p><p>理論上 IPSec 開啟後，所有指定 protocol 的 packet 離開網卡前會被 xfrm 攔截並且做 IPSec 的加密，同時所有指定 protocol 的 raw packet 進入網卡時應該要被 DROP。</p><p>然而 xfrm 上有一個特殊的參數叫做 level，他允許你加密離開網卡的流量的同時 allow 進入網卡的 raw packet，雖說這項設定預設不會開，但你難保你家 IT 設定了一整天 IPSec 還沒設起來整個很躁的時候會做甚麼事情對吧！</p><p><img src=https://github.com/user-attachments/assets/58e4082d-c02c-4299-a859-05bf197ea631 alt=image></p><iframe width=560 height=315 src="https://www.youtube.com/embed/y1ZlsGSu-RY?si=9klBHYJLEvnkw1aR" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin allowfullscreen></iframe><p>順帶一題，edgeos 你即使 level 屬性是預設值 require 他也會 allow raw packet，這是我的朋友 aka 現任<a href=https://www.ccns.io/>成大 CCNS</a> 的網管 <a href=https://zenwen.tw/>zen</a> 發現的，但基本上這件事還在待確認中。</p><h2 id=掃描與-real-world>掃描與 Real World</h2><p>最後來談談掃描的部分吧！</p><p>雖說<a href=https://www.top10vpn.com/research/tunneling-protocol-vulnerability/>這篇研究</a>已經講過具體的掃描方式了。</p><p>但我這邊也分享一下</p><h3 id=internal-access-able>Internal access able</h3><p>我們可以透過 victim 的 tunnel 在 victim 內網彈一個 ICMP request ping 出來，source ip 是 private IP destination ip 是 scanner 的 IP，並且在 ICMP ping 的 payload 內留一些標記以及寫下 tunnel 外層 src ip 與 dst ip，當我們可以從 wan 收到一模一樣的 ICMP ping 時，就可以確定對方的 router 是否存在該 protocol 的 tunnel，接著我們可以觀察傳過來的的 source ip 是否有變成 public 我們就可以知道 victim router 有沒有 NAT。</p><p><img src=https://github.com/user-attachments/assets/5cf3582e-5570-4f27-aa24-9fa9d02f16b4 alt=image></p><p><img src=https://github.com/user-attachments/assets/e3347bbf-949f-4682-aca2-051b501daa9d alt=image></p><p><img src=https://github.com/user-attachments/assets/10ca7e2d-3a10-493e-92f3-8574b1fa36e8 alt=image></p><p>接著檢查是否有 RPF，可以透過 victim 的 tunnel 在 victim 內網彈一個 ICMP reply pong 出來，source ip 是 private IP destination ip 是 scanner 的 IP，由於<a href=#tunnel-injection-to-internal-network>前面講過</a> &ldquo;一般的 router 不會對奇怪類型的封包做 SNAT 比如 TCP SYN/ACK、ICMP type 0 aka pong&rdquo; 因此就能確定從 victim router 出來絕對會是 private ip，接著只要看 scanner 有沒有收到就知道 victim 的 ISP 有沒有 RPF 了</p><p><img src=https://github.com/user-attachments/assets/6f3f4e5e-dee9-4929-9a93-edfb430a7fe2 alt=image></p><p><img src=https://github.com/user-attachments/assets/b4ba60ec-3f38-4086-979d-af123ce393e3 alt=image></p><h3 id=external-access-able>External access able</h3><p>由於 External access able 的 list 必定為 Internal access able 且有開 NAT 的 list 的 sub set，因此我們可以直接拿這個 IP list 再掃一次</p><p>一樣的架構但這次多一個可控的 target 機</p><p>透過 victim 的 tunnel 在 victim 內網彈一個 ICMP request ping 出來，source ip 是 scanner 的 IP destination ip 是 target 的 ip</p><p><img src=https://github.com/user-attachments/assets/11f911c5-5654-4810-a88a-9a79596a6c3b alt=image></p><p>如果是 External access able 的話這邊應該會對 public IP 做 NAT 之後送到 target 機，這邊 target 機要記得做 log</p><p><img src=https://github.com/user-attachments/assets/14d6f543-e252-49c7-ac93-ed754cd525ec alt=image></p><p>target 機收到後會回 ICMP reply pong 到 victim router</p><p><img src=https://github.com/user-attachments/assets/aed43a57-e31d-4eda-bde2-7c56ba9c588b alt=image></p><p>victim router 復原 destination ip 後會送回 scanner，這時候只需要檢查與比對 scanner 的 log 跟 target 的 log，我們就可以知道哪些是 External access able 的了。</p><p><img src=https://github.com/user-attachments/assets/dda1ce57-eae0-46a9-88bc-31241d4de968 alt=image></p><h3 id=掃描結果>掃描結果</h3><p>這邊針對不須 ip spoofing 的 tunnel 做掃描的結果</p><p>總共有：</p><ul><li>GRE: 230035 台<ul><li>有開 NAT: 191961 台<ul><li>External access able: 22875 台</li></ul></li></ul></li><li>IPIP: 76209 台<ul><li>有開 NAT: 23851<ul><li>External access able: 5438 台</li></ul></li></ul></li></ul><p>由於有些 ISP 配的是 dynamic ip 所以可能會有誤差</p><p>這邊也針對這些 IP 的 ASN 做分析可以看到有一坨中國的 IP</p><p>GRE:</p><p><img src=https://github.com/user-attachments/assets/efb0aa63-43e5-45a5-bf00-0dbd50c8e38a alt=image></p><p>IPIP:</p><p><img src=https://github.com/user-attachments/assets/a69480e1-7fdc-4045-9b6d-f33a749b5151 alt=image></p><h2 id=結語>結語</h2><p>最後只能說很可惜，因為剛剛好 <a href=https://github.com/123ojp>123ojp</a> 跟我撞到同一個研究且早了一點點，所以最後沒有投上 <a href=https://hitcon.org/2025/zh-TW/>HITCON 2025</a>，但是最後也有成功上去 HITCON Lightning Talk 講了一下這個有趣的小東西並補充了 <a href=https://github.com/123ojp>123ojp</a> 沒有講到也沒有想到的 <a href=#tunnel-injection-to-external-network>Tunnel Injection To External Network</a> 利用手法，且最後其時也聊得蠻開心的，之後我可能會試著拿這個研究去投一些其他的研討會看看。</p><p>順帶一題，雖說上面的 Demo 都是用我自己手刻的工具時做的，但是理論上再不需要做 <a href=#rpf-or-source-ip-verify-bypass>RPF Bypass</a> 的情況下，其實是可以用 <font color=red>5 行 linux ip 指令</font>就能夠把 internal 跟 external 的攻擊打出來，這部分就留給各位當作業了 XXD</p></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#感謝>感謝</a></li><li><a href=#前言>前言</a></li><li><a href=#what-is-tunnel>What is Tunnel</a></li><li><a href=#impact>Impact</a><ul><li><a href=#tunnel-injection-to-internal-network>Tunnel Injection to Internal Network</a></li><li><a href=#tunnel-injection-to-external-network>Tunnel Injection to External Network</a></li></ul></li><li><a href=#rpf-or-source-ip-verify-bypass>RPF or source ip verify bypass</a><ul><li><a href=#bypass-for-internal-network-access>Bypass for Internal Network Access</a></li><li><a href=#bypass-for-external-network-access>Bypass for External Network Access</a></li></ul></li><li><a href=#l2-tunnel-abuse>L2 Tunnel Abuse</a></li><li><a href=#ipsec>IPSec</a></li><li><a href=#掃描與-real-world>掃描與 Real World</a><ul><li><a href=#internal-access-able>Internal access able</a></li><li><a href=#external-access-able>External access able</a></li><li><a href=#掃描結果>掃描結果</a></li></ul></li><li><a href=#結語>結語</a></li></ul></nav></div></aside><aside class=tags><h5>Tags</h5><ul class="tags-ul list-unstyled list-inline"><li class=list-inline-item><a href=https://blog.chummydns.com/tags/cyber-security>Cyber Security</a></li><li class=list-inline-item><a href=https://blog.chummydns.com/tags/networking>Networking</a></li></ul></aside><aside class=social><h5>Social</h5><div class=social-content><ul class=list-inline><li class="list-inline-item text-center"><a target=_blank href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.chummydns.com%2fblogs%2ftunnel-injection%2f"><i class="fab fa-linkedin"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://twitter.com/share?text=%e5%88%b0%e8%99%95%e9%83%bd%e6%9c%89%e5%85%8d%e8%b2%bb%20VPN%20--%20Tunnel%20Injection&url=https%3a%2f%2fblog.chummydns.com%2fblogs%2ftunnel-injection%2f"><i class="fab fa-twitter"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://api.whatsapp.com/send?text=%e5%88%b0%e8%99%95%e9%83%bd%e6%9c%89%e5%85%8d%e8%b2%bb%20VPN%20--%20Tunnel%20Injection: https%3a%2f%2fblog.chummydns.com%2fblogs%2ftunnel-injection%2f"><i class="fab fa-whatsapp"></i></a></li><li class="list-inline-item text-center"><a target=_blank href='mailto:?subject=%e5%88%b0%e8%99%95%e9%83%bd%e6%9c%89%e5%85%8d%e8%b2%bb%20VPN%20--%20Tunnel%20Injection&amp;body=Check%20out%20this%20site https%3a%2f%2fblog.chummydns.com%2fblogs%2ftunnel-injection%2f'><i class="fa fa-envelope"></i></a></li></ul></div></aside><img src="https://count.getloli.com/@chumyblogbb1676456b12da16?darkmode=0&theme=rule34" alt=count></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><div class=progress><div id=scroll-progress-bar class=progress-bar role=progressbar aria-valuenow=0 aria-valuemin=0 aria-valuemax=100></div></div><script src=/js/scrollProgressBar.js></script><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script><script src=/js/readingTime.js></script></div><footer><div class="container py-3" id=recent-posts><div class="h3 text-center text-secondary py-3">Recent Posts</div><div class=col><div class="summary border p-3 card"><a href=https://blog.chummydns.com/blogs/tunnel-injection-english/><div class="font-bold text-color text-xl mb-2">Free VPNs Everywhere -- Tunnel Injection</div><p class=text-color></p><p class="text-sm text-secondary-color items-center">August 29, 2025</p></a></div><div class="summary border p-3 card"><a href=https://blog.chummydns.com/blogs/tunnel-injection/><div class="font-bold text-color text-xl mb-2">到處都有免費 VPN -- Tunnel Injection</div><p class=text-color></p><p class="text-sm text-secondary-color items-center">August 28, 2025</p></a></div><div class="summary border p-3 card"><a href=https://blog.chummydns.com/blogs/hitconctf-2025-qual/><div class="font-bold text-color text-xl mb-2">HITCON CTF 2025 Qual Writeup</div><p class=text-color></p><p class="text-sm text-secondary-color items-center">August 25, 2025</p></a></div></div></div><div class="text-center pt-2"><span class=px-1><a href=https://github.com/Jimmy01240397 aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://www.linkedin.com/in/%E8%81%BF%E5%96%84-%E8%94%A1-9b01b4254/ aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
</a></span><a href=https://twitter.com/jimmy01240397 aria-label=twitter><svg viewBox="0 0 48 48" width="48" height="48"><path fill="#03a9f4" d="M42 37c0 2.762-2.239 5-5 5H11c-2.762.0-5-2.238-5-5V11c0-2.762 2.238-5 5-5h26c2.761.0 5 2.238 5 5V37z"/><path fill="#fff" d="M36 17.12c-.882.391-1.999.758-3 .88 1.018-.604 2.633-1.862 3-3-.951.559-2.671 1.156-3.793 1.372C31.311 15.422 30.033 15 28.617 15 25.897 15 24 17.305 24 20v2c-4 0-7.9-3.047-10.327-6-.427.721-.667 1.565-.667 2.457.0 1.819 1.671 3.665 2.994 4.543-.807-.025-2.335-.641-3-1 0 .016.0.036.0.057.0 2.367 1.661 3.974 3.912 4.422C16.501 26.592 16 27 14.072 27c.626 1.935 3.773 2.958 5.928 3-1.686 1.307-4.692 2-7 2-.399.0-.615.022-1-.023C14.178 33.357 17.22 34 20 34c9.057.0 14-6.918 14-13.37.0-.212-.007-.922-.018-1.13C34.95 18.818 35.342 18.104 36 17.12"/></svg>
</a><a href=https://www.instagram.com/rm_rf_chumy/ aria-label=instagram><svg viewBox="0 0 48 48" width="48" height="48"><radialGradient id="yOrnnhliCrdS2gy~4tD8ma" cx="19.38" cy="42.035" r="44.899" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#fd5"/><stop offset=".328" stop-color="#ff543f"/><stop offset=".348" stop-color="#fc5245"/><stop offset=".504" stop-color="#e64771"/><stop offset=".643" stop-color="#d53e91"/><stop offset=".761" stop-color="#cc39a4"/><stop offset=".841" stop-color="#c837ab"/></radialGradient><path fill="url(#yOrnnhliCrdS2gy~4tD8ma)" d="M34.017 41.99l-20 .019c-4.4.004-8.003-3.592-8.008-7.992l-.019-20c-.004-4.4 3.592-8.003 7.992-8.008l20-.019c4.4-.004 8.003 3.592 8.008 7.992l.019 20C42.014 38.383 38.417 41.986 34.017 41.99z"/><radialGradient id="yOrnnhliCrdS2gy~4tD8mb" cx="11.786" cy="5.54" r="29.813" gradientTransform="matrix(1 0 0 .6663 0 1.849)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#4168c9"/><stop offset=".999" stop-color="#4168c9" stop-opacity="0"/></radialGradient><path fill="url(#yOrnnhliCrdS2gy~4tD8mb)" d="M34.017 41.99l-20 .019c-4.4.004-8.003-3.592-8.008-7.992l-.019-20c-.004-4.4 3.592-8.003 7.992-8.008l20-.019c4.4-.004 8.003 3.592 8.008 7.992l.019 20C42.014 38.383 38.417 41.986 34.017 41.99z"/><path fill="#fff" d="M24 31c-3.859.0-7-3.14-7-7s3.141-7 7-7 7 3.14 7 7-3.141 7-7 7zm0-12c-2.757.0-5 2.243-5 5s2.243 5 5 5 5-2.243 5-5-2.243-5-5-5z"/><circle cx="31.5" cy="16.5" r="1.5" fill="#fff"/><path fill="#fff" d="M30 37H18c-3.859.0-7-3.14-7-7V18c0-3.86 3.141-7 7-7h12c3.859.0 7 3.14 7 7v12c0 3.86-3.141 7-7 7zM18 13c-2.757.0-5 2.243-5 5v12c0 2.757 2.243 5 5 5h12c2.757.0 5-2.243 5-5V18c0-2.757-2.243-5-5-5H18z"/></svg>
</a><a href="https://www.facebook.com/profile.php?id=100005111161079" aria-label=facebook><svg viewBox="0 0 48 48" width="48" height="48"><path fill="#3f51b5" d="M42 37c0 2.762-2.238 5-5 5H11c-2.761.0-5-2.238-5-5V11c0-2.762 2.239-5 5-5h26c2.762.0 5 2.238 5 5V37z"/><path fill="#fff" d="M34.368 25H31v13h-5V25h-3v-4h3v-2.41c.002-3.508 1.459-5.59 5.592-5.59H35v4h-2.287C31.104 17 31 17.6 31 18.723V21h4L34.368 25z"/></svg></a></div><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center"><div class=pb-2><a href=https://blog.chummydns.com/ title="Chumy's Blog"><img alt="Footer logo" src=/myfav.png height=40px width=40px></a></div>&copy; 2025 All rights reserved<div class=text-secondary>Made with
<span class=text-danger>&#10084;
</span>and
<a href=https://github.com/gurusabarish/hugo-profile target=_blank title="Designed and developed by gurusabarish">Hugo Profile</a></div></div></div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","no4s0daf78")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-L02TG541PV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-L02TG541PV")</script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>